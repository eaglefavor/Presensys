-- ADVANCED SECURITY SCHEMA

-- 1. PROFILES (Extension of auth.users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  full_name TEXT,
  role TEXT CHECK (role IN ('admin', 'rep')) DEFAULT 'rep',
  status TEXT CHECK (status IN ('pending', 'verified', 'terminated')) DEFAULT 'pending',
  invalid_tries INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW())
);

-- 2. ACCESS CODES
CREATE TABLE IF NOT EXISTS public.access_codes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,
  created_by UUID REFERENCES public.profiles(id),
  is_used BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW())
);

-- 3. ENABLE RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.access_codes ENABLE ROW LEVEL SECURITY;

-- 4. POLICIES
-- Profiles: Users can read their own profile. Admin can read all.
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Admins have full access to profiles" ON public.profiles FOR ALL USING (
  EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Access Codes: Only admin can manage codes.
CREATE POLICY "Admins manage codes" ON public.access_codes FOR ALL USING (
  EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
);
-- Users can check if a code exists during verification (handled via RPC for security)

-- 5. TRIGGER: Create profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role, status)
  VALUES (
    NEW.id, 
    NEW.raw_user_meta_data->>'full_name', 
    CASE WHEN NEW.email = 'eaglefavor@users.noreply.github.com' THEN 'admin' ELSE 'rep' END,
    CASE WHEN NEW.email = 'eaglefavor@users.noreply.github.com' THEN 'verified' ELSE 'pending' END
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 6. RPC: Verify Access Code
CREATE OR REPLACE FUNCTION public.verify_access_code(input_code TEXT)
RETURNS JSON AS $$
DECLARE
  v_user_id UUID := auth.uid();
  v_status TEXT;
  v_tries INTEGER;
  v_code_exists BOOLEAN;
BEGIN
  -- Get current user status
  SELECT status, invalid_tries INTO v_status, v_tries FROM public.profiles WHERE id = v_user_id;
  
  IF v_status = 'terminated' THEN
    RETURN json_build_object('success', false, 'message', 'Account terminated.');
  END IF;

  -- Check if code is valid and unused
  SELECT EXISTS(SELECT 1 FROM public.access_codes WHERE code = input_code AND is_used = FALSE) INTO v_code_exists;

  IF v_code_exists THEN
    -- Grant access
    UPDATE public.profiles SET status = 'verified', invalid_tries = 0 WHERE id = v_user_id;
    UPDATE public.access_codes SET is_used = TRUE WHERE code = input_code;
    RETURN json_build_object('success', true);
  ELSE
    -- Increment tries
    v_tries := v_tries + 1;
    IF v_tries >= 20 THEN
      UPDATE public.profiles SET status = 'terminated' WHERE id = v_user_id;
      -- Note: Actual user deletion from auth.users requires service role, 
      -- but marking as terminated blocks all RLS access.
      RETURN json_build_object('success', false, 'message', 'Max tries exceeded. Account terminated.');
    ELSE
      UPDATE public.profiles SET invalid_tries = v_tries WHERE id = v_user_id;
      RETURN json_build_object('success', false, 'message', 'Invalid code. ' || (20 - v_tries) || ' tries left.', 'tries_left', 20 - v_tries);
    END IF;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
